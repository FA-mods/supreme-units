{"version":3,"file":"489.0990cc4d454fa9d35379.bundle.js","mappings":"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","sources":["webpack://InfragisticsBlazor/../node_modules/event-target-shim/index.mjs"],"sourcesContent":["/**\n * Assert a condition.\n * @param condition The condition that it should satisfy.\n * @param message The error message.\n * @param args The arguments for replacing placeholders in the message.\n */\nfunction assertType(condition, message, ...args) {\n    if (!condition) {\n        throw new TypeError(format(message, args));\n    }\n}\n/**\n * Convert a text and arguments to one string.\n * @param message The formating text\n * @param args The arguments.\n */\nfunction format(message, args) {\n    let i = 0;\n    return message.replace(/%[os]/gu, () => anyToString(args[i++]));\n}\n/**\n * Convert a value to a string representation.\n * @param x The value to get the string representation.\n */\nfunction anyToString(x) {\n    if (typeof x !== \"object\" || x === null) {\n        return String(x);\n    }\n    return Object.prototype.toString.call(x);\n}\n\nlet currentErrorHandler;\n/**\n * Set the error handler.\n * @param value The error handler to set.\n */\nfunction setErrorHandler(value) {\n    assertType(typeof value === \"function\" || value === undefined, \"The error handler must be a function or undefined, but got %o.\", value);\n    currentErrorHandler = value;\n}\n/**\n * Print a error message.\n * @param maybeError The error object.\n */\nfunction reportError(maybeError) {\n    try {\n        const error = maybeError instanceof Error\n            ? maybeError\n            : new Error(anyToString(maybeError));\n        // Call the user-defined error handler if exists.\n        if (currentErrorHandler) {\n            currentErrorHandler(error);\n            return;\n        }\n        // Dispatch an `error` event if this is on a browser.\n        if (typeof dispatchEvent === \"function\" &&\n            typeof ErrorEvent === \"function\") {\n            dispatchEvent(new ErrorEvent(\"error\", { error, message: error.message }));\n        }\n        // Emit an `uncaughtException` event if this is on Node.js.\n        //istanbul ignore else\n        else if (typeof process !== \"undefined\" &&\n            typeof process.emit === \"function\") {\n            process.emit(\"uncaughtException\", error);\n            return;\n        }\n        // Otherwise, print the error.\n        console.error(error);\n    }\n    catch (_a) {\n        // ignore.\n    }\n}\n\n/**\n * The global object.\n */\n//istanbul ignore next\nconst Global = typeof window !== \"undefined\"\n    ? window\n    : typeof self !== \"undefined\"\n        ? self\n        : typeof global !== \"undefined\"\n            ? global\n            : typeof globalThis !== \"undefined\"\n                ? globalThis\n                : undefined;\n\nlet currentWarnHandler;\n/**\n * Set the warning handler.\n * @param value The warning handler to set.\n */\nfunction setWarningHandler(value) {\n    assertType(typeof value === \"function\" || value === undefined, \"The warning handler must be a function or undefined, but got %o.\", value);\n    currentWarnHandler = value;\n}\n/**\n * The warning information.\n */\nclass Warning {\n    constructor(code, message) {\n        this.code = code;\n        this.message = message;\n    }\n    /**\n     * Report this warning.\n     * @param args The arguments of the warning.\n     */\n    warn(...args) {\n        var _a;\n        try {\n            // Call the user-defined warning handler if exists.\n            if (currentWarnHandler) {\n                currentWarnHandler({ ...this, args });\n                return;\n            }\n            // Otherwise, print the warning.\n            const stack = ((_a = new Error().stack) !== null && _a !== void 0 ? _a : \"\").replace(/^(?:.+?\\n){2}/gu, \"\\n\");\n            console.warn(this.message, ...args, stack);\n        }\n        catch (_b) {\n            // Ignore.\n        }\n    }\n}\n\nconst InitEventWasCalledWhileDispatching = new Warning(\"W01\", \"Unable to initialize event under dispatching.\");\nconst FalsyWasAssignedToCancelBubble = new Warning(\"W02\", \"Assigning any falsy value to 'cancelBubble' property has no effect.\");\nconst TruthyWasAssignedToReturnValue = new Warning(\"W03\", \"Assigning any truthy value to 'returnValue' property has no effect.\");\nconst NonCancelableEventWasCanceled = new Warning(\"W04\", \"Unable to preventDefault on non-cancelable events.\");\nconst CanceledInPassiveListener = new Warning(\"W05\", \"Unable to preventDefault inside passive event listener invocation.\");\nconst EventListenerWasDuplicated = new Warning(\"W06\", \"An event listener wasn't added because it has been added already: %o, %o\");\nconst OptionWasIgnored = new Warning(\"W07\", \"The %o option value was abandoned because the event listener wasn't added as duplicated.\");\nconst InvalidEventListener = new Warning(\"W08\", \"The 'callback' argument must be a function or an object that has 'handleEvent' method: %o\");\nconst InvalidAttributeHandler = new Warning(\"W09\", \"Event attribute handler must be a function: %o\");\n\n/*eslint-disable class-methods-use-this */\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * `EventTarget` shim can control the internal state of this `Event` objects.\n * @see https://dom.spec.whatwg.org/#event\n */\nclass Event {\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-none\n     */\n    static get NONE() {\n        return NONE;\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n     */\n    static get CAPTURING_PHASE() {\n        return CAPTURING_PHASE;\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-at_target\n     */\n    static get AT_TARGET() {\n        return AT_TARGET;\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n     */\n    static get BUBBLING_PHASE() {\n        return BUBBLING_PHASE;\n    }\n    /**\n     * Initialize this event instance.\n     * @param type The type of this event.\n     * @param eventInitDict Options to initialize.\n     * @see https://dom.spec.whatwg.org/#dom-event-event\n     */\n    constructor(type, eventInitDict) {\n        Object.defineProperty(this, \"isTrusted\", {\n            value: false,\n            enumerable: true,\n        });\n        const opts = eventInitDict !== null && eventInitDict !== void 0 ? eventInitDict : {};\n        internalDataMap.set(this, {\n            type: String(type),\n            bubbles: Boolean(opts.bubbles),\n            cancelable: Boolean(opts.cancelable),\n            composed: Boolean(opts.composed),\n            target: null,\n            currentTarget: null,\n            stopPropagationFlag: false,\n            stopImmediatePropagationFlag: false,\n            canceledFlag: false,\n            inPassiveListenerFlag: false,\n            dispatchFlag: false,\n            timeStamp: Date.now(),\n        });\n    }\n    /**\n     * The type of this event.\n     * @see https://dom.spec.whatwg.org/#dom-event-type\n     */\n    get type() {\n        return $(this).type;\n    }\n    /**\n     * The event target of the current dispatching.\n     * @see https://dom.spec.whatwg.org/#dom-event-target\n     */\n    get target() {\n        return $(this).target;\n    }\n    /**\n     * The event target of the current dispatching.\n     * @deprecated Use the `target` property instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-srcelement\n     */\n    get srcElement() {\n        return $(this).target;\n    }\n    /**\n     * The event target of the current dispatching.\n     * @see https://dom.spec.whatwg.org/#dom-event-currenttarget\n     */\n    get currentTarget() {\n        return $(this).currentTarget;\n    }\n    /**\n     * The event target of the current dispatching.\n     * This doesn't support node tree.\n     * @see https://dom.spec.whatwg.org/#dom-event-composedpath\n     */\n    composedPath() {\n        const currentTarget = $(this).currentTarget;\n        if (currentTarget) {\n            return [currentTarget];\n        }\n        return [];\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-none\n     */\n    get NONE() {\n        return NONE;\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n     */\n    get CAPTURING_PHASE() {\n        return CAPTURING_PHASE;\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-at_target\n     */\n    get AT_TARGET() {\n        return AT_TARGET;\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n     */\n    get BUBBLING_PHASE() {\n        return BUBBLING_PHASE;\n    }\n    /**\n     * The current event phase.\n     * @see https://dom.spec.whatwg.org/#dom-event-eventphase\n     */\n    get eventPhase() {\n        return $(this).dispatchFlag ? 2 : 0;\n    }\n    /**\n     * Stop event bubbling.\n     * Because this shim doesn't support node tree, this merely changes the `cancelBubble` property value.\n     * @see https://dom.spec.whatwg.org/#dom-event-stoppropagation\n     */\n    stopPropagation() {\n        $(this).stopPropagationFlag = true;\n    }\n    /**\n     * `true` if event bubbling was stopped.\n     * @deprecated\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n     */\n    get cancelBubble() {\n        return $(this).stopPropagationFlag;\n    }\n    /**\n     * Stop event bubbling if `true` is set.\n     * @deprecated Use the `stopPropagation()` method instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n     */\n    set cancelBubble(value) {\n        if (value) {\n            $(this).stopPropagationFlag = true;\n        }\n        else {\n            FalsyWasAssignedToCancelBubble.warn();\n        }\n    }\n    /**\n     * Stop event bubbling and subsequent event listener callings.\n     * @see https://dom.spec.whatwg.org/#dom-event-stopimmediatepropagation\n     */\n    stopImmediatePropagation() {\n        const data = $(this);\n        data.stopPropagationFlag = data.stopImmediatePropagationFlag = true;\n    }\n    /**\n     * `true` if this event will bubble.\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbles\n     */\n    get bubbles() {\n        return $(this).bubbles;\n    }\n    /**\n     * `true` if this event can be canceled by the `preventDefault()` method.\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelable\n     */\n    get cancelable() {\n        return $(this).cancelable;\n    }\n    /**\n     * `true` if the default behavior will act.\n     * @deprecated Use the `defaultPrevented` proeprty instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n     */\n    get returnValue() {\n        return !$(this).canceledFlag;\n    }\n    /**\n     * Cancel the default behavior if `false` is set.\n     * @deprecated Use the `preventDefault()` method instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n     */\n    set returnValue(value) {\n        if (!value) {\n            setCancelFlag($(this));\n        }\n        else {\n            TruthyWasAssignedToReturnValue.warn();\n        }\n    }\n    /**\n     * Cancel the default behavior.\n     * @see https://dom.spec.whatwg.org/#dom-event-preventdefault\n     */\n    preventDefault() {\n        setCancelFlag($(this));\n    }\n    /**\n     * `true` if the default behavior was canceled.\n     * @see https://dom.spec.whatwg.org/#dom-event-defaultprevented\n     */\n    get defaultPrevented() {\n        return $(this).canceledFlag;\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     */\n    get composed() {\n        return $(this).composed;\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-istrusted\n     */\n    //istanbul ignore next\n    get isTrusted() {\n        return false;\n    }\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-timestamp\n     */\n    get timeStamp() {\n        return $(this).timeStamp;\n    }\n    /**\n     * @deprecated Don't use this method. The constructor did initialization.\n     */\n    initEvent(type, bubbles = false, cancelable = false) {\n        const data = $(this);\n        if (data.dispatchFlag) {\n            InitEventWasCalledWhileDispatching.warn();\n            return;\n        }\n        internalDataMap.set(this, {\n            ...data,\n            type: String(type),\n            bubbles: Boolean(bubbles),\n            cancelable: Boolean(cancelable),\n            target: null,\n            currentTarget: null,\n            stopPropagationFlag: false,\n            stopImmediatePropagationFlag: false,\n            canceledFlag: false,\n        });\n    }\n}\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst NONE = 0;\nconst CAPTURING_PHASE = 1;\nconst AT_TARGET = 2;\nconst BUBBLING_PHASE = 3;\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap = new WeakMap();\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $(event, name = \"this\") {\n    const retv = internalDataMap.get(event);\n    assertType(retv != null, \"'%s' must be an object that Event constructor created, but got another one: %o\", name, event);\n    return retv;\n}\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data private data.\n */\nfunction setCancelFlag(data) {\n    if (data.inPassiveListenerFlag) {\n        CanceledInPassiveListener.warn();\n        return;\n    }\n    if (!data.cancelable) {\n        NonCancelableEventWasCanceled.warn();\n        return;\n    }\n    data.canceledFlag = true;\n}\n// Set enumerable\nObject.defineProperty(Event, \"NONE\", { enumerable: true });\nObject.defineProperty(Event, \"CAPTURING_PHASE\", { enumerable: true });\nObject.defineProperty(Event, \"AT_TARGET\", { enumerable: true });\nObject.defineProperty(Event, \"BUBBLING_PHASE\", { enumerable: true });\nconst keys = Object.getOwnPropertyNames(Event.prototype);\nfor (let i = 0; i < keys.length; ++i) {\n    if (keys[i] === \"constructor\") {\n        continue;\n    }\n    Object.defineProperty(Event.prototype, keys[i], { enumerable: true });\n}\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, Global.Event.prototype);\n}\n\n/**\n * Create a new InvalidStateError instance.\n * @param message The error message.\n */\nfunction createInvalidStateError(message) {\n    if (Global.DOMException) {\n        return new Global.DOMException(message, \"InvalidStateError\");\n    }\n    if (DOMException == null) {\n        DOMException = class DOMException extends Error {\n            constructor(msg) {\n                super(msg);\n                if (Error.captureStackTrace) {\n                    Error.captureStackTrace(this, DOMException);\n                }\n            }\n            // eslint-disable-next-line class-methods-use-this\n            get code() {\n                return 11;\n            }\n            // eslint-disable-next-line class-methods-use-this\n            get name() {\n                return \"InvalidStateError\";\n            }\n        };\n        Object.defineProperties(DOMException.prototype, {\n            code: { enumerable: true },\n            name: { enumerable: true },\n        });\n        defineErrorCodeProperties(DOMException);\n        defineErrorCodeProperties(DOMException.prototype);\n    }\n    return new DOMException(message);\n}\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nlet DOMException;\nconst ErrorCodeMap = {\n    INDEX_SIZE_ERR: 1,\n    DOMSTRING_SIZE_ERR: 2,\n    HIERARCHY_REQUEST_ERR: 3,\n    WRONG_DOCUMENT_ERR: 4,\n    INVALID_CHARACTER_ERR: 5,\n    NO_DATA_ALLOWED_ERR: 6,\n    NO_MODIFICATION_ALLOWED_ERR: 7,\n    NOT_FOUND_ERR: 8,\n    NOT_SUPPORTED_ERR: 9,\n    INUSE_ATTRIBUTE_ERR: 10,\n    INVALID_STATE_ERR: 11,\n    SYNTAX_ERR: 12,\n    INVALID_MODIFICATION_ERR: 13,\n    NAMESPACE_ERR: 14,\n    INVALID_ACCESS_ERR: 15,\n    VALIDATION_ERR: 16,\n    TYPE_MISMATCH_ERR: 17,\n    SECURITY_ERR: 18,\n    NETWORK_ERR: 19,\n    ABORT_ERR: 20,\n    URL_MISMATCH_ERR: 21,\n    QUOTA_EXCEEDED_ERR: 22,\n    TIMEOUT_ERR: 23,\n    INVALID_NODE_TYPE_ERR: 24,\n    DATA_CLONE_ERR: 25,\n};\nfunction defineErrorCodeProperties(obj) {\n    const keys = Object.keys(ErrorCodeMap);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const value = ErrorCodeMap[key];\n        Object.defineProperty(obj, key, {\n            get() {\n                return value;\n            },\n            configurable: true,\n            enumerable: true,\n        });\n    }\n}\n\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * This class controls the internal state of `Event`.\n * @see https://dom.spec.whatwg.org/#interface-event\n */\nclass EventWrapper extends Event {\n    /**\n     * Wrap a given event object to control states.\n     * @param event The event-like object to wrap.\n     */\n    static wrap(event) {\n        return new (getWrapperClassOf(event))(event);\n    }\n    constructor(event) {\n        super(event.type, {\n            bubbles: event.bubbles,\n            cancelable: event.cancelable,\n            composed: event.composed,\n        });\n        if (event.cancelBubble) {\n            super.stopPropagation();\n        }\n        if (event.defaultPrevented) {\n            super.preventDefault();\n        }\n        internalDataMap$1.set(this, { original: event });\n        // Define accessors\n        const keys = Object.keys(event);\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i];\n            if (!(key in this)) {\n                Object.defineProperty(this, key, defineRedirectDescriptor(event, key));\n            }\n        }\n    }\n    stopPropagation() {\n        super.stopPropagation();\n        const { original } = $$1(this);\n        if (\"stopPropagation\" in original) {\n            original.stopPropagation();\n        }\n    }\n    get cancelBubble() {\n        return super.cancelBubble;\n    }\n    set cancelBubble(value) {\n        super.cancelBubble = value;\n        const { original } = $$1(this);\n        if (\"cancelBubble\" in original) {\n            original.cancelBubble = value;\n        }\n    }\n    stopImmediatePropagation() {\n        super.stopImmediatePropagation();\n        const { original } = $$1(this);\n        if (\"stopImmediatePropagation\" in original) {\n            original.stopImmediatePropagation();\n        }\n    }\n    get returnValue() {\n        return super.returnValue;\n    }\n    set returnValue(value) {\n        super.returnValue = value;\n        const { original } = $$1(this);\n        if (\"returnValue\" in original) {\n            original.returnValue = value;\n        }\n    }\n    preventDefault() {\n        super.preventDefault();\n        const { original } = $$1(this);\n        if (\"preventDefault\" in original) {\n            original.preventDefault();\n        }\n    }\n    get timeStamp() {\n        const { original } = $$1(this);\n        if (\"timeStamp\" in original) {\n            return original.timeStamp;\n        }\n        return super.timeStamp;\n    }\n}\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap$1 = new WeakMap();\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @returns The private data of the event.\n */\nfunction $$1(event) {\n    const retv = internalDataMap$1.get(event);\n    assertType(retv != null, \"'this' is expected an Event object, but got\", event);\n    return retv;\n}\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrapperClassCache = new WeakMap();\n// Make association for wrappers.\nwrapperClassCache.set(Object.prototype, EventWrapper);\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n    wrapperClassCache.set(Global.Event.prototype, EventWrapper);\n}\n/**\n * Get the wrapper class of a given prototype.\n * @param originalEvent The event object to wrap.\n */\nfunction getWrapperClassOf(originalEvent) {\n    const prototype = Object.getPrototypeOf(originalEvent);\n    if (prototype == null) {\n        return EventWrapper;\n    }\n    let wrapper = wrapperClassCache.get(prototype);\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapperClassOf(prototype), prototype);\n        wrapperClassCache.set(prototype, wrapper);\n    }\n    return wrapper;\n}\n/**\n * Define new wrapper class.\n * @param BaseEventWrapper The base wrapper class.\n * @param originalPrototype The prototype of the original event.\n */\nfunction defineWrapper(BaseEventWrapper, originalPrototype) {\n    class CustomEventWrapper extends BaseEventWrapper {\n    }\n    const keys = Object.keys(originalPrototype);\n    for (let i = 0; i < keys.length; ++i) {\n        Object.defineProperty(CustomEventWrapper.prototype, keys[i], defineRedirectDescriptor(originalPrototype, keys[i]));\n    }\n    return CustomEventWrapper;\n}\n/**\n * Get the property descriptor to redirect a given property.\n */\nfunction defineRedirectDescriptor(obj, key) {\n    const d = Object.getOwnPropertyDescriptor(obj, key);\n    return {\n        get() {\n            const original = $$1(this).original;\n            const value = original[key];\n            if (typeof value === \"function\") {\n                return value.bind(original);\n            }\n            return value;\n        },\n        set(value) {\n            const original = $$1(this).original;\n            original[key] = value;\n        },\n        configurable: d.configurable,\n        enumerable: d.enumerable,\n    };\n}\n\n/**\n * Create a new listener.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n * @param signalListener The abort event listener for the abort signal.\n */\nfunction createListener(callback, capture, passive, once, signal, signalListener) {\n    return {\n        callback,\n        flags: (capture ? 1 /* Capture */ : 0) |\n            (passive ? 2 /* Passive */ : 0) |\n            (once ? 4 /* Once */ : 0),\n        signal,\n        signalListener,\n    };\n}\n/**\n * Set the `removed` flag to the given listener.\n * @param listener The listener to check.\n */\nfunction setRemoved(listener) {\n    listener.flags |= 8 /* Removed */;\n}\n/**\n * Check if the given listener has the `capture` flag or not.\n * @param listener The listener to check.\n */\nfunction isCapture(listener) {\n    return (listener.flags & 1 /* Capture */) === 1 /* Capture */;\n}\n/**\n * Check if the given listener has the `passive` flag or not.\n * @param listener The listener to check.\n */\nfunction isPassive(listener) {\n    return (listener.flags & 2 /* Passive */) === 2 /* Passive */;\n}\n/**\n * Check if the given listener has the `once` flag or not.\n * @param listener The listener to check.\n */\nfunction isOnce(listener) {\n    return (listener.flags & 4 /* Once */) === 4 /* Once */;\n}\n/**\n * Check if the given listener has the `removed` flag or not.\n * @param listener The listener to check.\n */\nfunction isRemoved(listener) {\n    return (listener.flags & 8 /* Removed */) === 8 /* Removed */;\n}\n/**\n * Call an event listener.\n * @param listener The listener to call.\n * @param target The event target object for `thisArg`.\n * @param event The event object for the first argument.\n * @param attribute `true` if this callback is an event attribute handler.\n */\nfunction invokeCallback({ callback }, target, event) {\n    try {\n        if (typeof callback === \"function\") {\n            callback.call(target, event);\n        }\n        else if (typeof callback.handleEvent === \"function\") {\n            callback.handleEvent(event);\n        }\n    }\n    catch (thrownError) {\n        reportError(thrownError);\n    }\n}\n\n/**\n * Find the index of given listener.\n * This returns `-1` if not found.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n */\nfunction findIndexOfListener({ listeners }, callback, capture) {\n    for (let i = 0; i < listeners.length; ++i) {\n        if (listeners[i].callback === callback &&\n            isCapture(listeners[i]) === capture) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Add the given listener.\n * Does copy-on-write if needed.\n * @param list The listener list.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n */\nfunction addListener(list, callback, capture, passive, once, signal) {\n    let signalListener;\n    if (signal) {\n        signalListener = removeListener.bind(null, list, callback, capture);\n        signal.addEventListener(\"abort\", signalListener);\n    }\n    const listener = createListener(callback, capture, passive, once, signal, signalListener);\n    if (list.cow) {\n        list.cow = false;\n        list.listeners = [...list.listeners, listener];\n    }\n    else {\n        list.listeners.push(listener);\n    }\n    return listener;\n}\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n * @returns `true` if it mutated the list directly.\n */\nfunction removeListener(list, callback, capture) {\n    const index = findIndexOfListener(list, callback, capture);\n    if (index !== -1) {\n        return removeListenerAt(list, index);\n    }\n    return false;\n}\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param index The index of the target listener.\n * @param disableCow Disable copy-on-write if true.\n * @returns `true` if it mutated the `listeners` array directly.\n */\nfunction removeListenerAt(list, index, disableCow = false) {\n    const listener = list.listeners[index];\n    // Set the removed flag.\n    setRemoved(listener);\n    // Dispose the abort signal listener if exists.\n    if (listener.signal) {\n        listener.signal.removeEventListener(\"abort\", listener.signalListener);\n    }\n    // Remove it from the array.\n    if (list.cow && !disableCow) {\n        list.cow = false;\n        list.listeners = list.listeners.filter((_, i) => i !== index);\n        return false;\n    }\n    list.listeners.splice(index, 1);\n    return true;\n}\n\n/**\n * Create a new `ListenerListMap` object.\n */\nfunction createListenerListMap() {\n    return Object.create(null);\n}\n/**\n * Get the listener list of the given type.\n * If the listener list has not been initialized, initialize and return it.\n * @param listenerMap The listener list map.\n * @param type The event type to get.\n */\nfunction ensureListenerList(listenerMap, type) {\n    var _a;\n    return ((_a = listenerMap[type]) !== null && _a !== void 0 ? _a : (listenerMap[type] = {\n        attrCallback: undefined,\n        attrListener: undefined,\n        cow: false,\n        listeners: [],\n    }));\n}\n\n/**\n * An implementation of the `EventTarget` interface.\n * @see https://dom.spec.whatwg.org/#eventtarget\n */\nclass EventTarget {\n    /**\n     * Initialize this instance.\n     */\n    constructor() {\n        internalDataMap$2.set(this, createListenerListMap());\n    }\n    // Implementation\n    addEventListener(type0, callback0, options0) {\n        const listenerMap = $$2(this);\n        const { callback, capture, once, passive, signal, type, } = normalizeAddOptions(type0, callback0, options0);\n        if (callback == null || (signal === null || signal === void 0 ? void 0 : signal.aborted)) {\n            return;\n        }\n        const list = ensureListenerList(listenerMap, type);\n        // Find existing listener.\n        const i = findIndexOfListener(list, callback, capture);\n        if (i !== -1) {\n            warnDuplicate(list.listeners[i], passive, once, signal);\n            return;\n        }\n        // Add the new listener.\n        addListener(list, callback, capture, passive, once, signal);\n    }\n    // Implementation\n    removeEventListener(type0, callback0, options0) {\n        const listenerMap = $$2(this);\n        const { callback, capture, type } = normalizeOptions(type0, callback0, options0);\n        const list = listenerMap[type];\n        if (callback != null && list) {\n            removeListener(list, callback, capture);\n        }\n    }\n    // Implementation\n    dispatchEvent(e) {\n        const list = $$2(this)[String(e.type)];\n        if (list == null) {\n            return true;\n        }\n        const event = e instanceof Event ? e : EventWrapper.wrap(e);\n        const eventData = $(event, \"event\");\n        if (eventData.dispatchFlag) {\n            throw createInvalidStateError(\"This event has been in dispatching.\");\n        }\n        eventData.dispatchFlag = true;\n        eventData.target = eventData.currentTarget = this;\n        if (!eventData.stopPropagationFlag) {\n            const { cow, listeners } = list;\n            // Set copy-on-write flag.\n            list.cow = true;\n            // Call listeners.\n            for (let i = 0; i < listeners.length; ++i) {\n                const listener = listeners[i];\n                // Skip if removed.\n                if (isRemoved(listener)) {\n                    continue;\n                }\n                // Remove this listener if has the `once` flag.\n                if (isOnce(listener) && removeListenerAt(list, i, !cow)) {\n                    // Because this listener was removed, the next index is the\n                    // same as the current value.\n                    i -= 1;\n                }\n                // Call this listener with the `passive` flag.\n                eventData.inPassiveListenerFlag = isPassive(listener);\n                invokeCallback(listener, this, event);\n                eventData.inPassiveListenerFlag = false;\n                // Stop if the `event.stopImmediatePropagation()` method was called.\n                if (eventData.stopImmediatePropagationFlag) {\n                    break;\n                }\n            }\n            // Restore copy-on-write flag.\n            if (!cow) {\n                list.cow = false;\n            }\n        }\n        eventData.target = null;\n        eventData.currentTarget = null;\n        eventData.stopImmediatePropagationFlag = false;\n        eventData.stopPropagationFlag = false;\n        eventData.dispatchFlag = false;\n        return !eventData.canceledFlag;\n    }\n}\n/**\n * Internal data.\n */\nconst internalDataMap$2 = new WeakMap();\n/**\n * Get private data.\n * @param target The event target object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $$2(target, name = \"this\") {\n    const retv = internalDataMap$2.get(target);\n    assertType(retv != null, \"'%s' must be an object that EventTarget constructor created, but got another one: %o\", name, target);\n    return retv;\n}\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeAddOptions(type, callback, options) {\n    var _a;\n    assertCallback(callback);\n    if (typeof options === \"object\" && options !== null) {\n        return {\n            type: String(type),\n            callback: callback !== null && callback !== void 0 ? callback : undefined,\n            capture: Boolean(options.capture),\n            passive: Boolean(options.passive),\n            once: Boolean(options.once),\n            signal: (_a = options.signal) !== null && _a !== void 0 ? _a : undefined,\n        };\n    }\n    return {\n        type: String(type),\n        callback: callback !== null && callback !== void 0 ? callback : undefined,\n        capture: Boolean(options),\n        passive: false,\n        once: false,\n        signal: undefined,\n    };\n}\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeOptions(type, callback, options) {\n    assertCallback(callback);\n    if (typeof options === \"object\" && options !== null) {\n        return {\n            type: String(type),\n            callback: callback !== null && callback !== void 0 ? callback : undefined,\n            capture: Boolean(options.capture),\n        };\n    }\n    return {\n        type: String(type),\n        callback: callback !== null && callback !== void 0 ? callback : undefined,\n        capture: Boolean(options),\n    };\n}\n/**\n * Assert the type of 'callback' argument.\n * @param callback The callback to check.\n */\nfunction assertCallback(callback) {\n    if (typeof callback === \"function\" ||\n        (typeof callback === \"object\" &&\n            callback !== null &&\n            typeof callback.handleEvent === \"function\")) {\n        return;\n    }\n    if (callback == null || typeof callback === \"object\") {\n        InvalidEventListener.warn(callback);\n        return;\n    }\n    throw new TypeError(format(InvalidEventListener.message, [callback]));\n}\n/**\n * Print warning for duplicated.\n * @param listener The current listener that is duplicated.\n * @param passive The passive flag of the new duplicated listener.\n * @param once The once flag of the new duplicated listener.\n * @param signal The signal object of the new duplicated listener.\n */\nfunction warnDuplicate(listener, passive, once, signal) {\n    EventListenerWasDuplicated.warn(isCapture(listener) ? \"capture\" : \"bubble\", listener.callback);\n    if (isPassive(listener) !== passive) {\n        OptionWasIgnored.warn(\"passive\");\n    }\n    if (isOnce(listener) !== once) {\n        OptionWasIgnored.warn(\"once\");\n    }\n    if (listener.signal !== signal) {\n        OptionWasIgnored.warn(\"signal\");\n    }\n}\n// Set enumerable\nconst keys$1 = Object.getOwnPropertyNames(EventTarget.prototype);\nfor (let i = 0; i < keys$1.length; ++i) {\n    if (keys$1[i] === \"constructor\") {\n        continue;\n    }\n    Object.defineProperty(EventTarget.prototype, keys$1[i], { enumerable: true });\n}\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (typeof Global !== \"undefined\" &&\n    typeof Global.EventTarget !== \"undefined\") {\n    Object.setPrototypeOf(EventTarget.prototype, Global.EventTarget.prototype);\n}\n\n/**\n * Get the current value of a given event attribute.\n * @param target The `EventTarget` object to get.\n * @param type The event type.\n */\nfunction getEventAttributeValue(target, type) {\n    var _a, _b;\n    const listMap = $$2(target, \"target\");\n    return (_b = (_a = listMap[type]) === null || _a === void 0 ? void 0 : _a.attrCallback) !== null && _b !== void 0 ? _b : null;\n}\n/**\n * Set an event listener to a given event attribute.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction setEventAttributeValue(target, type, callback) {\n    if (callback != null && typeof callback !== \"function\") {\n        InvalidAttributeHandler.warn(callback);\n    }\n    if (typeof callback === \"function\" ||\n        (typeof callback === \"object\" && callback !== null)) {\n        upsertEventAttributeListener(target, type, callback);\n    }\n    else {\n        removeEventAttributeListener(target, type);\n    }\n}\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n/**\n * Update or insert the given event attribute handler.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction upsertEventAttributeListener(target, type, callback) {\n    const list = ensureListenerList($$2(target, \"target\"), String(type));\n    list.attrCallback = callback;\n    if (list.attrListener == null) {\n        list.attrListener = addListener(list, defineEventAttributeCallback(list), false, false, false, undefined);\n    }\n}\n/**\n * Remove the given event attribute handler.\n * @param target The `EventTarget` object to remove.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction removeEventAttributeListener(target, type) {\n    const listMap = $$2(target, \"target\");\n    const list = listMap[String(type)];\n    if (list && list.attrListener) {\n        removeListener(list, list.attrListener.callback, false);\n        list.attrCallback = list.attrListener = undefined;\n    }\n}\n/**\n * Define the callback function for the given listener list object.\n * It calls `attrCallback` property if the property value is a function.\n * @param list The `ListenerList` object.\n */\nfunction defineEventAttributeCallback(list) {\n    return function (event) {\n        const callback = list.attrCallback;\n        if (typeof callback === \"function\") {\n            callback.call(this, event);\n        }\n    };\n}\n\n/**\n * Define an `EventTarget` class that has event attibutes.\n * @param types The types to define event attributes.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nfunction defineCustomEventTarget(...types) {\n    class CustomEventTarget extends EventTarget {\n    }\n    for (let i = 0; i < types.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, types[i]);\n    }\n    return CustomEventTarget;\n}\n/**\n * Define an event attribute.\n * @param target The `EventTarget` object to define an event attribute.\n * @param type The event type to define.\n * @param _eventClass Unused, but to infer `Event` class type.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nfunction defineEventAttribute(target, type, _eventClass) {\n    Object.defineProperty(target, `on${type}`, {\n        get() {\n            return getEventAttributeValue(this, type);\n        },\n        set(value) {\n            setEventAttributeValue(this, type, value);\n        },\n        configurable: true,\n        enumerable: true,\n    });\n}\n\nexport default EventTarget;\nexport { Event, EventTarget, defineCustomEventTarget, defineEventAttribute, getEventAttributeValue, setErrorHandler, setEventAttributeValue, setWarningHandler };\n//# sourceMappingURL=index.mjs.map\n"],"names":["assertType","condition","message","args","TypeError","format","i","replace","anyToString","x","String","Object","prototype","toString","call","currentErrorHandler","setErrorHandler","value","undefined","Global","window","self","global","globalThis","currentWarnHandler","setWarningHandler","Warning","constructor","code","this","warn","_a","stack","Error","console","_b","InitEventWasCalledWhileDispatching","FalsyWasAssignedToCancelBubble","TruthyWasAssignedToReturnValue","NonCancelableEventWasCanceled","CanceledInPassiveListener","EventListenerWasDuplicated","OptionWasIgnored","InvalidEventListener","InvalidAttributeHandler","Event","NONE","CAPTURING_PHASE","AT_TARGET","BUBBLING_PHASE","type","eventInitDict","defineProperty","enumerable","opts","internalDataMap","set","bubbles","Boolean","cancelable","composed","target","currentTarget","stopPropagationFlag","stopImmediatePropagationFlag","canceledFlag","inPassiveListenerFlag","dispatchFlag","timeStamp","Date","now","$","srcElement","composedPath","eventPhase","stopPropagation","cancelBubble","stopImmediatePropagation","data","returnValue","setCancelFlag","preventDefault","defaultPrevented","isTrusted","initEvent","WeakMap","event","name","retv","get","keys","getOwnPropertyNames","length","DOMException","setPrototypeOf","ErrorCodeMap","INDEX_SIZE_ERR","DOMSTRING_SIZE_ERR","HIERARCHY_REQUEST_ERR","WRONG_DOCUMENT_ERR","INVALID_CHARACTER_ERR","NO_DATA_ALLOWED_ERR","NO_MODIFICATION_ALLOWED_ERR","NOT_FOUND_ERR","NOT_SUPPORTED_ERR","INUSE_ATTRIBUTE_ERR","INVALID_STATE_ERR","SYNTAX_ERR","INVALID_MODIFICATION_ERR","NAMESPACE_ERR","INVALID_ACCESS_ERR","VALIDATION_ERR","TYPE_MISMATCH_ERR","SECURITY_ERR","NETWORK_ERR","ABORT_ERR","URL_MISMATCH_ERR","QUOTA_EXCEEDED_ERR","TIMEOUT_ERR","INVALID_NODE_TYPE_ERR","DATA_CLONE_ERR","defineErrorCodeProperties","obj","key","configurable","EventWrapper","static","getWrapperClassOf","super","internalDataMap$1","original","defineRedirectDescriptor","$$1","wrapperClassCache","originalEvent","getPrototypeOf","wrapper","BaseEventWrapper","originalPrototype","CustomEventWrapper","defineWrapper","d","getOwnPropertyDescriptor","bind","isCapture","listener","flags","isPassive","isOnce","isRemoved","invokeCallback","callback","handleEvent","thrownError","maybeError","error","dispatchEvent","ErrorEvent","process","emit","reportError","findIndexOfListener","listeners","capture","addListener","list","passive","once","signal","signalListener","removeListener","addEventListener","createListener","cow","push","index","removeListenerAt","disableCow","setRemoved","removeEventListener","filter","_","splice","ensureListenerList","listenerMap","attrCallback","attrListener","EventTarget","internalDataMap$2","create","type0","callback0","options0","$$2","options","assertCallback","normalizeAddOptions","aborted","warnDuplicate","normalizeOptions","e","wrap","eventData","msg","captureStackTrace","defineProperties","keys$1","getEventAttributeValue","setEventAttributeValue","defineEventAttributeCallback","upsertEventAttributeListener","removeEventAttributeListener","defineCustomEventTarget","types","CustomEventTarget","defineEventAttribute","_eventClass"],"sourceRoot":""}