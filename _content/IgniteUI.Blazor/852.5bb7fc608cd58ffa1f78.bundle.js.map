{"version":3,"file":"852.5bb7fc608cd58ffa1f78.bundle.js","mappings":"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","sources":["webpack://InfragisticsBlazor/../node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js","webpack://InfragisticsBlazor/../node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js","webpack://InfragisticsBlazor/../node_modules/@lit-labs/virtualizer/layouts/flow.js","webpack://InfragisticsBlazor/../node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js"],"sourcesContent":["export class SizeCache {\n    constructor(config) {\n        this._map = new Map();\n        this._roundAverageSize = true;\n        this.totalSize = 0;\n        if ((config === null || config === void 0 ? void 0 : config.roundAverageSize) === false) {\n            this._roundAverageSize = false;\n        }\n    }\n    set(index, value) {\n        const prev = this._map.get(index) || 0;\n        this._map.set(index, value);\n        this.totalSize += value - prev;\n    }\n    get averageSize() {\n        if (this._map.size > 0) {\n            const average = this.totalSize / this._map.size;\n            return this._roundAverageSize ? Math.round(average) : average;\n        }\n        return 0;\n    }\n    getSize(index) {\n        return this._map.get(index);\n    }\n    clear() {\n        this._map.clear();\n        this.totalSize = 0;\n    }\n}\n//# sourceMappingURL=SizeCache.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nlet _ET;\nlet ET;\nexport default async function EventTarget() {\n    return ET || init();\n}\nasync function init() {\n    _ET = window.EventTarget;\n    try {\n        new _ET();\n    }\n    catch {\n        _ET = (await import('event-target-shim')).EventTarget;\n    }\n    return (ET = _ET);\n}\n//# sourceMappingURL=EventTarget.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { SizeCache } from './shared/SizeCache.js';\nimport { BaseLayout, dim1 } from './shared/BaseLayout.js';\nexport const flow = (config) => Object.assign({\n    type: FlowLayout,\n}, config);\nfunction leadingMargin(direction) {\n    return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\nfunction trailingMargin(direction) {\n    return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\nfunction offset(direction) {\n    return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\nfunction collapseMargins(a, b) {\n    const m = [a, b].sort();\n    return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\nclass MetricsCache {\n    constructor() {\n        this._childSizeCache = new SizeCache();\n        this._marginSizeCache = new SizeCache();\n        this._metricsCache = new Map();\n    }\n    update(metrics, direction) {\n        var _a, _b;\n        const marginsToUpdate = new Set();\n        Object.keys(metrics).forEach((key) => {\n            const k = Number(key);\n            this._metricsCache.set(k, metrics[k]);\n            this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n            marginsToUpdate.add(k);\n            marginsToUpdate.add(k + 1);\n        });\n        for (const k of marginsToUpdate) {\n            const a = ((_a = this._metricsCache.get(k)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n            const b = ((_b = this._metricsCache.get(k - 1)) === null || _b === void 0 ? void 0 : _b[trailingMargin(direction)]) || 0;\n            this._marginSizeCache.set(k, collapseMargins(a, b));\n        }\n    }\n    get averageChildSize() {\n        return this._childSizeCache.averageSize;\n    }\n    get totalChildSize() {\n        return this._childSizeCache.totalSize;\n    }\n    get averageMarginSize() {\n        return this._marginSizeCache.averageSize;\n    }\n    get totalMarginSize() {\n        return this._marginSizeCache.totalSize;\n    }\n    getLeadingMarginValue(index, direction) {\n        var _a;\n        return ((_a = this._metricsCache.get(index)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n    }\n    getChildSize(index) {\n        return this._childSizeCache.getSize(index);\n    }\n    getMarginSize(index) {\n        return this._marginSizeCache.getSize(index);\n    }\n    clear() {\n        this._childSizeCache.clear();\n        this._marginSizeCache.clear();\n        this._metricsCache.clear();\n    }\n}\nexport class FlowLayout extends BaseLayout {\n    constructor() {\n        super(...arguments);\n        /**\n         * Initial estimate of item size\n         */\n        this._itemSize = { width: 100, height: 100 };\n        /**\n         * Indices of children mapped to their (position and length) in the scrolling\n         * direction. Used to keep track of children that are in range.\n         */\n        this._physicalItems = new Map();\n        /**\n         * Used in tandem with _physicalItems to track children in range across\n         * reflows.\n         */\n        this._newPhysicalItems = new Map();\n        /**\n         * Width and height of children by their index.\n         */\n        this._metricsCache = new MetricsCache();\n        /**\n         * anchorIdx is the anchor around which we reflow. It is designed to allow\n         * jumping to any point of the scroll size. We choose it once and stick with\n         * it until stable. _first and _last are deduced around it.\n         */\n        this._anchorIdx = null;\n        /**\n         * Position in the scrolling direction of the anchor child.\n         */\n        this._anchorPos = null;\n        /**\n         * Whether all children in range were in range during the previous reflow.\n         */\n        this._stable = true;\n        this._measureChildren = true;\n        this._estimate = true;\n    }\n    // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n    // })\n    // constructor(config: Layout1dConfig) {\n    //   super(config);\n    // }\n    get measureChildren() {\n        return this._measureChildren;\n    }\n    /**\n     * Determine the average size of all children represented in the sizes\n     * argument.\n     */\n    updateItemSizes(sizes) {\n        this._metricsCache.update(sizes, this.direction);\n        // if (this._nMeasured) {\n        // this._updateItemSize();\n        this._scheduleReflow();\n        // }\n    }\n    /**\n     * Set the average item size based on the total length and number of children\n     * in range.\n     */\n    // _updateItemSize() {\n    //   // Keep integer values.\n    //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n    // }\n    _getPhysicalItem(idx) {\n        var _a;\n        return (_a = this._newPhysicalItems.get(idx)) !== null && _a !== void 0 ? _a : this._physicalItems.get(idx);\n    }\n    _getSize(idx) {\n        const item = this._getPhysicalItem(idx);\n        return item && this._metricsCache.getChildSize(idx);\n    }\n    _getAverageSize() {\n        return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n    }\n    /**\n     * Returns the position in the scrolling direction of the item at idx.\n     * Estimates it if the item at idx is not in the DOM.\n     */\n    _getPosition(idx) {\n        var _a;\n        const item = this._getPhysicalItem(idx);\n        const { averageMarginSize } = this._metricsCache;\n        return idx === 0\n            ? (_a = this._metricsCache.getMarginSize(0)) !== null && _a !== void 0 ? _a : averageMarginSize\n            : item\n                ? item.pos\n                : averageMarginSize + idx * (averageMarginSize + this._getAverageSize());\n    }\n    _calculateAnchor(lower, upper) {\n        if (lower <= 0) {\n            return 0;\n        }\n        if (upper > this._scrollSize - this._viewDim1) {\n            return this._totalItems - 1;\n        }\n        return Math.max(0, Math.min(this._totalItems - 1, Math.floor((lower + upper) / 2 / this._delta)));\n    }\n    _getAnchor(lower, upper) {\n        if (this._physicalItems.size === 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._first < 0) {\n            console.error('_getAnchor: negative _first');\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._last < 0) {\n            console.error('_getAnchor: negative _last');\n            return this._calculateAnchor(lower, upper);\n        }\n        const firstItem = this._getPhysicalItem(this._first), lastItem = this._getPhysicalItem(this._last), firstMin = firstItem.pos, lastMin = lastItem.pos, lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n        if (lastMax < lower) {\n            // Window is entirely past physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        if (firstMin > upper) {\n            // Window is entirely before physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        // Window contains a physical item\n        // Find one, starting with the one that was previously first visible\n        let candidateIdx = this._firstVisible - 1;\n        let cMax = -Infinity;\n        while (cMax < lower) {\n            const candidate = this._getPhysicalItem(++candidateIdx);\n            cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n        }\n        return candidateIdx;\n    }\n    /**\n     * Updates _first and _last based on items that should be in the current\n     * viewed range.\n     */\n    _getActiveItems() {\n        if (this._viewDim1 === 0 || this._totalItems === 0) {\n            this._clearItems();\n        }\n        else {\n            this._getItems();\n        }\n    }\n    /**\n     * Sets the range to empty.\n     */\n    _clearItems() {\n        this._first = -1;\n        this._last = -1;\n        this._physicalMin = 0;\n        this._physicalMax = 0;\n        const items = this._newPhysicalItems;\n        this._newPhysicalItems = this._physicalItems;\n        this._newPhysicalItems.clear();\n        this._physicalItems = items;\n        this._stable = true;\n    }\n    /*\n     * Updates _first and _last based on items that should be in the given range.\n     */\n    _getItems() {\n        var _a, _b;\n        const items = this._newPhysicalItems;\n        this._stable = true;\n        let lower, upper;\n        // The anchorIdx is the anchor around which we reflow. It is designed to\n        // allow jumping to any point of the scroll size. We choose it once and\n        // stick with it until stable. first and last are deduced around it.\n        // If we have a scrollToIndex, we anchor on the given\n        // index and set the scroll position accordingly\n        if (this._scrollToIndex >= 0) {\n            this._anchorIdx = Math.min(this._scrollToIndex, this._totalItems - 1);\n            this._anchorPos = this._getPosition(this._anchorIdx);\n            this._scrollIfNeeded();\n        }\n        // Determine the lower and upper bounds of the region to be\n        // rendered, relative to the viewport\n        lower = this._scrollPosition - this._overhang; //leadingOverhang;\n        upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n        if (upper < 0 || lower > this._scrollSize) {\n            this._clearItems();\n            return;\n        }\n        // If we are scrolling to a specific index or if we are doing another\n        // pass to stabilize a previously started reflow, we will already\n        // have an anchor. If not, establish an anchor now.\n        if (this._anchorIdx === null || this._anchorPos === null) {\n            this._anchorIdx = this._getAnchor(lower, upper);\n            this._anchorPos = this._getPosition(this._anchorIdx);\n        }\n        let anchorSize = this._getSize(this._anchorIdx);\n        if (anchorSize === undefined) {\n            this._stable = false;\n            anchorSize = this._getAverageSize();\n        }\n        const anchorLeadingMargin = (_a = this._metricsCache.getMarginSize(this._anchorIdx)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize;\n        const anchorTrailingMargin = (_b = this._metricsCache.getMarginSize(this._anchorIdx + 1)) !== null && _b !== void 0 ? _b : this._metricsCache.averageMarginSize;\n        if (this._anchorIdx === 0) {\n            this._anchorPos = anchorLeadingMargin;\n        }\n        if (this._anchorIdx === this._totalItems - 1) {\n            this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n        }\n        // Anchor might be outside bounds, so prefer correcting the error and keep\n        // that anchorIdx.\n        let anchorErr = 0;\n        if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n            anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n        }\n        if (this._anchorPos - anchorLeadingMargin > upper) {\n            anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n        }\n        if (anchorErr) {\n            this._scrollPosition -= anchorErr;\n            lower -= anchorErr;\n            upper -= anchorErr;\n            this._scrollError += anchorErr;\n        }\n        items.set(this._anchorIdx, { pos: this._anchorPos, size: anchorSize });\n        this._first = this._last = this._anchorIdx;\n        this._physicalMin = this._anchorPos - anchorLeadingMargin;\n        this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n        while (this._physicalMin > lower && this._first > 0) {\n            let size = this._getSize(--this._first);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._first);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            this._physicalMin -= size;\n            const pos = this._physicalMin;\n            items.set(this._first, { pos, size });\n            this._physicalMin -= margin;\n            if (this._stable === false && this._estimate === false) {\n                break;\n            }\n        }\n        while (this._physicalMax < upper && this._last < this._totalItems - 1) {\n            let size = this._getSize(++this._last);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._last);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            const pos = this._physicalMax;\n            items.set(this._last, { pos, size });\n            this._physicalMax += size + margin;\n            if (!this._stable && !this._estimate) {\n                break;\n            }\n        }\n        // This handles the cases where we were relying on estimated sizes.\n        const extentErr = this._calculateError();\n        if (extentErr) {\n            this._physicalMin -= extentErr;\n            this._physicalMax -= extentErr;\n            this._anchorPos -= extentErr;\n            this._scrollPosition -= extentErr;\n            items.forEach((item) => (item.pos -= extentErr));\n            this._scrollError += extentErr;\n        }\n        if (this._stable) {\n            this._newPhysicalItems = this._physicalItems;\n            this._newPhysicalItems.clear();\n            this._physicalItems = items;\n        }\n    }\n    _calculateError() {\n        if (this._first === 0) {\n            return this._physicalMin;\n        }\n        else if (this._physicalMin <= 0) {\n            return this._physicalMin - this._first * this._delta;\n        }\n        else if (this._last === this._totalItems - 1) {\n            return this._physicalMax - this._scrollSize;\n        }\n        else if (this._physicalMax >= this._scrollSize) {\n            return (this._physicalMax -\n                this._scrollSize +\n                (this._totalItems - 1 - this._last) * this._delta);\n        }\n        return 0;\n    }\n    // TODO: Can this be made to inherit from base, with proper hooks?\n    _reflow() {\n        const { _first, _last, _scrollSize } = this;\n        this._updateScrollSize();\n        this._getActiveItems();\n        if (this._scrollSize !== _scrollSize) {\n            this._emitScrollSize();\n        }\n        this._updateVisibleIndices();\n        this._emitRange();\n        if (this._first === -1 && this._last === -1) {\n            this._resetReflowState();\n        }\n        else if (this._first !== _first || this._last !== _last) {\n            this._emitChildPositions();\n            this._emitScrollError();\n        }\n        else {\n            this._emitChildPositions();\n            this._emitScrollError();\n            this._resetReflowState();\n        }\n    }\n    _resetReflowState() {\n        this._anchorIdx = null;\n        this._anchorPos = null;\n        this._stable = true;\n    }\n    _updateScrollSize() {\n        const { averageMarginSize } = this._metricsCache;\n        this._scrollSize = Math.max(1, this._totalItems * (averageMarginSize + this._getAverageSize()) +\n            averageMarginSize);\n    }\n    /**\n     * Returns the average size (precise or estimated) of an item in the scrolling direction,\n     * including any surrounding space.\n     */\n    get _delta() {\n        const { averageMarginSize } = this._metricsCache;\n        return this._getAverageSize() + averageMarginSize;\n    }\n    /**\n     * Returns the top and left positioning of the item at idx.\n     */\n    _getItemPosition(idx) {\n        var _a;\n        return {\n            [this._positionDim]: this._getPosition(idx),\n            [this._secondaryPositionDim]: 0,\n            [offset(this.direction)]: -((_a = this._metricsCache.getLeadingMarginValue(idx, this.direction)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize),\n        };\n    }\n    /**\n     * Returns the height and width of the item at idx.\n     */\n    _getItemSize(idx) {\n        var _a;\n        return {\n            [this._sizeDim]: (this._getSize(idx) || this._getAverageSize()) +\n                ((_a = this._metricsCache.getMarginSize(idx + 1)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize),\n            [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim],\n        };\n    }\n    _viewDim2Changed() {\n        this._scheduleReflow();\n    }\n}\n//# sourceMappingURL=flow.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport EventTarget from '../../polyfillLoaders/EventTarget.js';\nexport function dim1(direction) {\n    return direction === 'horizontal' ? 'width' : 'height';\n}\nexport function dim2(direction) {\n    return direction === 'horizontal' ? 'height' : 'width';\n}\nexport function pos1(direction) {\n    return direction === 'horizontal' ? 'left' : 'top';\n}\nexport function pos2(direction) {\n    return direction === 'horizontal' ? 'top' : 'left';\n}\nexport class BaseLayout {\n    constructor(config) {\n        /**\n         * The last set viewport scroll position.\n         */\n        this._latestCoords = { left: 0, top: 0 };\n        /**\n         * Scrolling direction.\n         */\n        this._direction = null;\n        /**\n         * Dimensions of the viewport.\n         */\n        this._viewportSize = { width: 0, height: 0 };\n        /**\n         * Flag for debouncing asynchnronous reflow requests.\n         */\n        this._pendingReflow = false;\n        this._pendingLayoutUpdate = false;\n        /**\n         * Index of the item that has been scrolled to via the public API. When the\n         * viewport is otherwise scrolled, this value is set back to -1.\n         */\n        this._scrollToIndex = -1;\n        /**\n         * When a child is scrolled to, the offset from the top of the child and the\n         * top of the viewport. Value is a proportion of the item size.\n         */\n        this._scrollToAnchor = 0;\n        /**\n         * The index of the first item intersecting the viewport.\n         */\n        this._firstVisible = 0;\n        /**\n         * The index of the last item intersecting the viewport.\n         */\n        this._lastVisible = 0;\n        this._eventTargetPromise = EventTarget().then((Ctor) => {\n            this._eventTarget = new Ctor();\n        });\n        /**\n         * Pixel offset in the scroll direction of the first child.\n         */\n        this._physicalMin = 0;\n        /**\n         * Pixel offset in the scroll direction of the last child.\n         */\n        this._physicalMax = 0;\n        /**\n         * Index of the first child.\n         */\n        this._first = -1;\n        /**\n         * Index of the last child.\n         */\n        this._last = -1;\n        /**\n         * Length in the scrolling direction.\n         */\n        this._sizeDim = 'height';\n        /**\n         * Length in the non-scrolling direction.\n         */\n        this._secondarySizeDim = 'width';\n        /**\n         * Position in the scrolling direction.\n         */\n        this._positionDim = 'top';\n        /**\n         * Position in the non-scrolling direction.\n         */\n        this._secondaryPositionDim = 'left';\n        /**\n         * Current scroll offset in pixels.\n         */\n        this._scrollPosition = 0;\n        /**\n         * Difference between current scroll offset and scroll offset calculated due\n         * to a reflow.\n         */\n        this._scrollError = 0;\n        /**\n         * Total number of items that could possibly be displayed. Used to help\n         * calculate the scroll size.\n         */\n        this._totalItems = 0;\n        /**\n         * The total (estimated) length of all items in the scrolling direction.\n         */\n        this._scrollSize = 1;\n        /**\n         * Number of pixels beyond the viewport to still include\n         * in the active range of items.\n         */\n        // TODO (graynorton): Probably want to make this something we calculate based\n        // on viewport size, item size, other factors, possibly still with a dial of some kind\n        this._overhang = 1000;\n        this._eventTarget = null;\n        // Delay setting config so that subclasses do setup work first\n        Promise.resolve().then(() => (this.config = config || this._defaultConfig));\n    }\n    get _defaultConfig() {\n        return {\n            direction: 'vertical',\n        };\n    }\n    set config(config) {\n        Object.assign(this, Object.assign({}, this._defaultConfig, config));\n    }\n    get config() {\n        return {\n            direction: this.direction,\n        };\n    }\n    /**\n     * Maximum index of children + 1, to help estimate total height of the scroll\n     * space.\n     */\n    get totalItems() {\n        return this._totalItems;\n    }\n    set totalItems(num) {\n        const _num = Number(num);\n        if (_num !== this._totalItems) {\n            this._totalItems = _num;\n            this._scheduleReflow();\n        }\n    }\n    /**\n     * Primary scrolling direction.\n     */\n    get direction() {\n        return this._direction;\n    }\n    set direction(dir) {\n        // Force it to be either horizontal or vertical.\n        dir = dir === 'horizontal' ? dir : 'vertical';\n        if (dir !== this._direction) {\n            this._direction = dir;\n            this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n            this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n            this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n            this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n            this._triggerReflow();\n        }\n    }\n    /**\n     * Height and width of the viewport.\n     */\n    get viewportSize() {\n        return this._viewportSize;\n    }\n    set viewportSize(dims) {\n        const { _viewDim1, _viewDim2 } = this;\n        Object.assign(this._viewportSize, dims);\n        if (_viewDim2 !== this._viewDim2) {\n            // this._viewDim2Changed();\n            this._scheduleLayoutUpdate();\n        }\n        else if (_viewDim1 !== this._viewDim1) {\n            this._checkThresholds();\n        }\n    }\n    /**\n     * Scroll offset of the viewport.\n     */\n    get viewportScroll() {\n        return this._latestCoords;\n    }\n    set viewportScroll(coords) {\n        Object.assign(this._latestCoords, coords);\n        const oldPos = this._scrollPosition;\n        this._scrollPosition = this._latestCoords[this._positionDim];\n        if (oldPos !== this._scrollPosition) {\n            this._scrollPositionChanged(oldPos, this._scrollPosition);\n            this._updateVisibleIndices({ emit: true });\n        }\n        this._checkThresholds();\n    }\n    /**\n     * Perform a reflow if one has been scheduled.\n     */\n    reflowIfNeeded(force = false) {\n        if (force || this._pendingReflow) {\n            this._pendingReflow = false;\n            this._reflow();\n        }\n    }\n    /**\n     * Scroll to the child at the given index, and the given position within that\n     * child.\n     */\n    scrollToIndex(index, position = 'start') {\n        if (!Number.isFinite(index))\n            return;\n        index = Math.min(this.totalItems, Math.max(0, index));\n        this._scrollToIndex = index;\n        if (position === 'nearest') {\n            position = index > this._first + this._num / 2 ? 'end' : 'start';\n        }\n        switch (position) {\n            case 'start':\n                this._scrollToAnchor = 0;\n                break;\n            case 'center':\n                this._scrollToAnchor = 0.5;\n                break;\n            case 'end':\n                this._scrollToAnchor = 1;\n                break;\n            default:\n                throw new TypeError('position must be one of: start, center, end, nearest');\n        }\n        this._scheduleReflow();\n    }\n    async dispatchEvent(evt) {\n        await this._eventTargetPromise;\n        this._eventTarget.dispatchEvent(evt);\n    }\n    async addEventListener(type, listener, options) {\n        await this._eventTargetPromise;\n        this._eventTarget.addEventListener(type, listener, options);\n    }\n    async removeEventListener(type, callback, options) {\n        await this._eventTargetPromise;\n        this._eventTarget.removeEventListener(type, callback, options);\n    }\n    _updateLayout() {\n        // Override\n    }\n    // protected _viewDim2Changed(): void {\n    //   this._scheduleLayoutUpdate();\n    // }\n    /**\n     * The height or width of the viewport, whichever corresponds to the scrolling direction.\n     */\n    get _viewDim1() {\n        return this._viewportSize[this._sizeDim];\n    }\n    /**\n     * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n     */\n    get _viewDim2() {\n        return this._viewportSize[this._secondarySizeDim];\n    }\n    _scheduleReflow() {\n        this._pendingReflow = true;\n    }\n    _scheduleLayoutUpdate() {\n        this._pendingLayoutUpdate = true;\n        this._scheduleReflow();\n    }\n    // For triggering a reflow based on incoming changes to\n    // the layout config.\n    _triggerReflow() {\n        this._scheduleLayoutUpdate();\n        // TODO graynorton@: reflowIfNeeded() isn't really supposed\n        // to be called internally. Address in larger cleanup\n        // of virtualizer / layout interaction pattern.\n        // this.reflowIfNeeded(true);\n        Promise.resolve().then(() => this.reflowIfNeeded());\n    }\n    _reflow() {\n        if (this._pendingLayoutUpdate) {\n            this._updateLayout();\n            this._pendingLayoutUpdate = false;\n        }\n        this._updateScrollSize();\n        this._getActiveItems();\n        this._scrollIfNeeded();\n        this._updateVisibleIndices();\n        this._emitScrollSize();\n        this._emitRange();\n        this._emitChildPositions();\n        this._emitScrollError();\n    }\n    _scrollIfNeeded() {\n        if (this._scrollToIndex === -1) {\n            return;\n        }\n        const index = this._scrollToIndex;\n        const anchor = this._scrollToAnchor;\n        const pos = this._getItemPosition(index)[this._positionDim];\n        const size = this._getItemSize(index)[this._sizeDim];\n        const curAnchorPos = this._scrollPosition + this._viewDim1 * anchor;\n        const newAnchorPos = pos + size * anchor;\n        // Ensure scroll position is an integer within scroll bounds.\n        const scrollPosition = Math.floor(Math.min(this._scrollSize - this._viewDim1, Math.max(0, this._scrollPosition - curAnchorPos + newAnchorPos)));\n        this._scrollError += this._scrollPosition - scrollPosition;\n        this._scrollPosition = scrollPosition;\n    }\n    _emitRange(inProps = undefined) {\n        const detail = Object.assign({\n            first: this._first,\n            last: this._last,\n            num: this._num,\n            firstVisible: this._firstVisible,\n            lastVisible: this._lastVisible,\n        }, inProps);\n        this.dispatchEvent(new CustomEvent('rangechange', { detail }));\n    }\n    _emitScrollSize() {\n        const detail = {\n            [this._sizeDim]: this._scrollSize,\n            [this._secondarySizeDim]: null,\n        };\n        this.dispatchEvent(new CustomEvent('scrollsizechange', { detail }));\n    }\n    _emitScrollError() {\n        if (this._scrollError) {\n            const detail = {\n                [this._positionDim]: this._scrollError,\n                [this._secondaryPositionDim]: 0,\n            };\n            this.dispatchEvent(new CustomEvent('scrollerrorchange', { detail }));\n            this._scrollError = 0;\n        }\n    }\n    /**\n     * Get or estimate the top and left positions of items in the current range.\n     * Emit an itempositionchange event with these positions.\n     */\n    _emitChildPositions() {\n        const detail = {};\n        for (let idx = this._first; idx <= this._last; idx++) {\n            detail[idx] = this._getItemPosition(idx);\n        }\n        this.dispatchEvent(new CustomEvent('itempositionchange', { detail }));\n    }\n    /**\n     * Number of items to display.\n     */\n    get _num() {\n        if (this._first === -1 || this._last === -1) {\n            return 0;\n        }\n        return this._last - this._first + 1;\n    }\n    _checkThresholds() {\n        if (this._viewDim1 === 0 && this._num > 0) {\n            this._scheduleReflow();\n        }\n        else {\n            const min = Math.max(0, this._scrollPosition - this._overhang);\n            const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n            if (this._physicalMin > min || this._physicalMax < max) {\n                this._scheduleReflow();\n            }\n        }\n    }\n    /**\n     * Find the indices of the first and last items to intersect the viewport.\n     * Emit a visibleindiceschange event when either index changes.\n     */\n    _updateVisibleIndices(options) {\n        if (this._first === -1 || this._last === -1)\n            return;\n        let firstVisible = this._first;\n        while (firstVisible < this._last &&\n            Math.round(this._getItemPosition(firstVisible)[this._positionDim] +\n                this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n            firstVisible++;\n        }\n        let lastVisible = this._last;\n        while (lastVisible > this._first &&\n            Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >=\n                Math.round(this._scrollPosition + this._viewDim1)) {\n            lastVisible--;\n        }\n        if (firstVisible !== this._firstVisible ||\n            lastVisible !== this._lastVisible) {\n            this._firstVisible = firstVisible;\n            this._lastVisible = lastVisible;\n            if (options && options.emit) {\n                this._emitRange();\n            }\n        }\n    }\n    _scrollPositionChanged(oldPos, newPos) {\n        // When both values are bigger than the max scroll position, keep the\n        // current _scrollToIndex, otherwise invalidate it.\n        const maxPos = this._scrollSize - this._viewDim1;\n        if (oldPos < maxPos || newPos < maxPos) {\n            this._scrollToIndex = -1;\n        }\n    }\n}\n//# sourceMappingURL=BaseLayout.js.map"],"names":["SizeCache","constructor","config","this","_map","Map","_roundAverageSize","totalSize","roundAverageSize","set","index","value","prev","get","averageSize","size","average","Math","round","getSize","clear","_ET","ET","flow","Object","assign","type","FlowLayout","leadingMargin","direction","trailingMargin","collapseMargins","a","b","m","sort","min","max","MetricsCache","_childSizeCache","_marginSizeCache","_metricsCache","update","metrics","_a","_b","marginsToUpdate","Set","keys","forEach","key","k","Number","dim1","add","averageChildSize","totalChildSize","averageMarginSize","totalMarginSize","getLeadingMarginValue","getChildSize","getMarginSize","_latestCoords","left","top","_direction","_viewportSize","width","height","_pendingReflow","_pendingLayoutUpdate","_scrollToIndex","_scrollToAnchor","_firstVisible","_lastVisible","_eventTargetPromise","async","window","EventTarget","init","then","Ctor","_eventTarget","_physicalMin","_physicalMax","_first","_last","_sizeDim","_secondarySizeDim","_positionDim","_secondaryPositionDim","_scrollPosition","_scrollError","_totalItems","_scrollSize","_overhang","Promise","resolve","_defaultConfig","totalItems","num","_num","_scheduleReflow","dir","_triggerReflow","viewportSize","dims","_viewDim1","_viewDim2","_scheduleLayoutUpdate","_checkThresholds","viewportScroll","coords","oldPos","_scrollPositionChanged","_updateVisibleIndices","emit","reflowIfNeeded","force","_reflow","scrollToIndex","position","isFinite","TypeError","evt","dispatchEvent","listener","options","addEventListener","callback","removeEventListener","_updateLayout","_updateScrollSize","_getActiveItems","_scrollIfNeeded","_emitScrollSize","_emitRange","_emitChildPositions","_emitScrollError","anchor","pos","_getItemPosition","_getItemSize","curAnchorPos","newAnchorPos","scrollPosition","floor","inProps","detail","first","last","firstVisible","lastVisible","CustomEvent","idx","newPos","maxPos","super","arguments","_itemSize","_physicalItems","_newPhysicalItems","_anchorIdx","_anchorPos","_stable","_measureChildren","_estimate","measureChildren","updateItemSizes","sizes","_getPhysicalItem","_getSize","_getAverageSize","_getPosition","item","_calculateAnchor","lower","upper","_delta","_getAnchor","console","error","firstItem","lastItem","firstMin","candidateIdx","cMax","_clearItems","_getItems","items","anchorSize","undefined","anchorLeadingMargin","anchorTrailingMargin","anchorErr","margin","extentErr","_calculateError","_resetReflowState","_viewDim2Changed"],"sourceRoot":""}